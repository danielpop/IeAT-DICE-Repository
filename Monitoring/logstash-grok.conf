

input {
lumberjack{
port =>5000
type=> "log"
ssl_certificate => "/opt/certs/logstash-forwarder.crt"
ssl_key=> "/opt/private/logstash-forwarder.key"
}
  udp {
    port => 25826         # 25826 matches port specified in collectd.conf
    buffer_size => 1452   # 1452 is the default buffer size for Collectd
    codec => collectd { } # specific Collectd codec to invoke
    type => collectd
  }
}

filter{
if [type]=="cdhlog"{ #same as set in logstash-forwarder configuration json
  grok{
    break_on_match => false
    #metricssystem.MetricsSystem
    match=>["message","\A%{NUMBER:job_id} %{WORD:serviceType}.%{WORD:serviceMetrics}: Context=%{WORD:context}, Hostname=%{WORD:hostname1}-%{WORD%{WORD:hostname2}-%{WORD:hostname3}, NumActiveSources=%{NUMBER:NumActiveSources}, NumAllSources=%{NUMBER:NumAllSources}, NumActiveSinks=%{NUMBER:NumActiveSinks}, NumAllSinks=%{NUMBER:NumAllSinks}, Sink_diceNumOps=%{NUMBER:Sink_diceNumOps}, Sink_diceAvgTime=%{NUMBER:Sink_diceAvgTime}, Sink_diceDropped=%{NUMBER:Sink_diceDropped}, Sink_diceQsize=%{NUMBER:Sink_diceQsize}, SnapshotNumOps=%{NUMBER:SnapshotNumOps}, SnapshotAvgTime=%{NUMBER:SnapshotAvgTime}, PublishNumOps=%{NUMBER:PublishNumOps}, PublishAvgTime=%{NUMBER:PublishAvgTime}"]

    #ugi.UgiMetrics
    match=>["message","\A%{NUMBER:job_id} %{WORD:serviceType}.%{WORD:serviceMetrics}: Context=%{WORD:context}, Hostname=%{WORD:hostname1}-%{WORD%{WORD:hostname2}-%{WORD:hostname3}, LoginSuccessNumOps=%{NUMBER:LoginSuccessNumOps}, LoginSuccessAvgTime=%{NUMBER:LoginSuccessAvgTime}, LoginFailureNumOps=%{NUMBER:LoginFailureNumOps}, LoginFailureAvgTime=%{NUMBER:LoginFailureAvgTime}, GetGroupsNumOps=%{NUMBER:GetGroupsNumOps}, GetGroupsAvgTime=%{NUMBER:GetGroupsAvgTime}
    "]

    #jvm.JvmMetrics
    match=>["message","\A%{NUMBER:job_id} %{WORD:serviceType}.%{WORD:serviceMetrics}: Context=%{WORD:context}, ProcessName=%{WORD:ProcessName}, SessionId=%{WORD:SessionId}, Hostname=%{WORD:hostname1}-%{WORD%{WORD:hostname2}-%{WORD:hostname3}, MemNonHeapUsedM=%{NUMBER:MemNonHeapUsedM}, MemNonHeapCommittedM=%{NUMBER:MemNonHeapCommittedM}, MemNonHeapMaxM=%{NUMBER:MemNonHeapMaxM}, MemHeapUsedM=%{NUMBER:MemHeapUsedM}, MemHeapCommittedM=%{NUMBER:MemHeapCommittedM}, MemHeapMaxM=%{NUMBER:MemHeapMaxM}, MemMaxM=%{NUMBER:MemMaxM}, GcCountParNew=%{NUMBER:GcCountParNew}, GcTimeMillisParNew=%{NUMBER:GcTimeMillisParNew}, GcCountConcurrentMarkSweep=%{NUMBER:GcCountConcurrentMarkSweep}, GcTimeMillisConcurrentMarkSweep=%{NUMBER:GcTimeMillisConcurrentMarkSweep}, GcCount=%{NUMBER:GcCount}, GcTimeMillis=%{NUMBER:GcTimeMillis}, ThreadsNew=%{NUMBER:ThreadsNew}, ThreadsRunnable=%{NUMBER:ThreadsRunnable}, ThreadsBlocked=%{NUMBER:ThreadsBlocked}, ThreadsWaiting=%{NUMBER:ThreadsWaiting}, ThreadsTimedWaiting=%{NUMBER:ThreadsTimedWaiting}, ThreadsTerminated=%{NUMBER:ThreadsTerminated}, LogFatal=%{NUMBER:LogFatal}, LogError=%{NUMBER:LogError}, LogWarn=%{NUMBER:LogWarn}, LogInfo=%{NUMBER:LogInfo}"]

    #yarn.NodeManagerMetrics
    match=>["message","\A%{NUMBER:job_id} %{WORD:serviceType}.%{WORD:serviceMetrics}: Context=%{WORD:context}, Hostname=%{WORD:hostname1}-%{WORD%{WORD:hostname2}-%{WORD:hostname3}, ContainersLaunched=%{NUMBER:ContainersLaunched}, ContainersCompleted=%{NUMBER:ContainersCompleted}, ContainersFailed=%{NUMBER:ContainersFailed}, ContainersKilled=%{NUMBER:ContainersKilled}, ContainersIniting=%{NUMBER:ContainersIniting}, ContainersRunning=%{NUMBER:ContainersRunning}, AllocatedGB=%{NUMBER:AllocatedGB}, AllocatedContainers=%{NUMBER:AllocatedContainers}, AvailableGB=%{NUMBER:AvailableGB}, AllocatedVCores=%{NUMBER:AllocatedVCores}, AvailableVCores=%{NUMBER:AvailableVCores}, ContainerLaunchDurationNumOps=%{NUMBER:ContainerLaunchDurationNumOps}, ContainerLaunchDurationAvgTime=%{NUMBER:ContainerLaunchDurationAvgTime}"]

    #mapred.ShuffleMetrics
    match=>["message","\A%{NUMBER:job_id} %{WORD:serviceType}.%{WORD:serviceMetrics}: Context=%{WORD:context}, Hostname=%{WORD:hostname1}-%{WORD%{WORD:hostname2}-%{WORD:hostname3}, ShuffleOutputBytes=%{NUMBER:ShuffleOutputBytes}, ShuffleOutputsFailed=%{NUMBER:ShuffleOutputsFailed}, ShuffleOutputsOK=%{NUMBER:ShuffleOutputsOK}, ShuffleConnections=%{NUMBER:ShuffleConnections}"]

    #rpc.rpc
    match=>["message","\A%{NUMBER:job_id} %{WORD:serviceType}.%{WORD:serviceMetrics}: port=%{NUMBER:port}, Context=%{WORD:context}, Hostname=%{WORD:hostname1}-%{WORD%{WORD:hostname2}-%{WORD:hostname3}, ReceivedBytes=%{NUMBER:ReceivedBytes}, SentBytes=%{NUMBER:SentBytes}, RpcQueueTimeNumOps=%{NUMBER:RpcQueueTimeNumOps}, RpcQueueTimeAvgTime=%{NUMBER:RpcQueueTimeAvgTime}, RpcProcessingTimeNumOps=%{NUMBER:RpcProcessingTimeNumOps}, RpcProcessingTimeAvgTime=%{NUMBER:RpcProcessingTimeAvgTime}, RpcAuthenticationFailures=%{NUMBER:RpcAuthenticationFailures}, RpcAuthenticationSuccesses=%{NUMBER:RpcAuthenticationSuccesses}, RpcAuthorizationFailures=%{NUMBER:RpcAuthorizationFailures}, RpcAuthorizationSuccesses=%{NUMBER:RpcAuthorizationSuccesses}, NumOpenConnections=%{NUMBER:NumOpenConnections}, CallQueueLength=%{NUMBER:CallQueueLength}"]

    #rpcdetailed.rpcdetailed
    match=>["message","\A%{NUMBER:job_id} %{WORD:serviceType}.%{WORD:serviceMetrics}: port=%{NUMBER:port}, Context=%{WORD:context}, Hostname=%{WORD:hostname1}-%{WORD%{WORD:hostname2}-%{WORD:hostname3}"]
  }
 }
}
output {
  elasticsearch {
    cluster  => logstash # this matches out elasticsearch cluster.name
    protocol => http
  }
}



